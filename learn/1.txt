Great 👍 Let’s go through Chapter 5: File System in Node.js step by step with real-world engineering details and code examples.

---

 ⚡ Chapter 5: File System in Node.js

The `fs` module in Node.js provides an API to interact with the file system (read, write, update, delete). It supports both synchronous and asynchronous operations.

---

 🔹 § 5.1 fs Module Introduction

 The `fs` (File System) module is a core Node.js module (no installation needed).
 You import it like this:

js
const fs = require("fs");


 Capabilities:

   Create, read, update, delete files.
   Work with directories.
   Stream large files efficiently.

Example – checking if a file exists:

js
const fs = require("fs");

if (fs.existsSync("example.txt")) {
  console.log("File exists!");
} else {
  console.log("File does not exist!");
}


---

 🔹 § 5.2 Synchronous vs Asynchronous File Operations

Node.js provides two versions of most file system methods:

1. Synchronous (Blocking)

    Code execution waits until the operation completes.
    Simple but can block the event loop.
    Not recommended for production servers.

2. Asynchronous (Non-blocking)

    Uses callbacks or promises.
    The event loop stays free → better performance.
    Recommended for most use cases.

Example:

js
const fs = require("fs");

// Synchronous (Blocking)
const data = fs.readFileSync("example.txt", "utf8");
console.log("Sync Read:", data);

// Asynchronous (Non-blocking)
fs.readFile("example.txt", "utf8", (err, data) => {
  if (err) throw err;
  console.log("Async Read:", data);
});


👉 Engineering tip: Use async methods (`fs.promises` or callbacks) in production; sync is okay for scripts or initialization tasks.

---

 🔹 § 5.3 Reading and Writing Files

 1. Reading Files

 Async with callback:

js
fs.readFile("example.txt", "utf8", (err, data) => {
  if (err) {
    console.error("Error reading file:", err);
    return;
  }
  console.log("File Content:", data);
});


 Async with Promises:

js
const fsPromises = require("fs").promises;

async function readFileExample() {
  try {
    const data = await fsPromises.readFile("example.txt", "utf8");
    console.log("File Content:", data);
  } catch (err) {
    console.error("Error:", err);
  }
}
readFileExample();


 Sync version:

js
const data = fs.readFileSync("example.txt", "utf8");
console.log("Sync Read:", data);


---

 2. Writing Files

 Async (callback):

js
fs.writeFile("output.txt", "Hello, Node.js!", (err) => {
  if (err) throw err;
  console.log("File written successfully!");
});


 Append to file:

js
fs.appendFile("output.txt", "\nAppended text", (err) => {
  if (err) throw err;
  console.log("Text appended!");
});


 Sync version:

js
fs.writeFileSync("output.txt", "New content (overwrites old)");


---

 3. Streams for Large Files

For very large files, streams are more memory-efficient:

js
const readStream = fs.createReadStream("bigfile.txt", "utf8");

readStream.on("data", (chunk) => {
  console.log("Received chunk:", chunk);
});

readStream.on("end", () => {
  console.log("Finished reading");
});


 Unlike `readFile()`, which loads the whole file into memory, streams process chunks progressively.

---

  Summary

 § 5.1 fs Module → Core module to work with files/directories.
 § 5.2 Sync vs Async → Async is preferred for servers; sync may block event loop.
 § 5.3 Reading & Writing Files → Use `readFile`, `writeFile`, `appendFile`, or streams for large files.

---

👉 Do you want me to also include directory operations (creating, reading, deleting folders) in this section, or should we keep that for a later chapter?
